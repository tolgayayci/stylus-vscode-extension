{
  "ERC20 Smart Contract Example": {
    "prefix": "erc20_example",
    "body": [
      "use alloc::{string::String, vec::Vec};",
      "use core::marker::PhantomData;",
      "use stylus_sdk::{",
      "    alloy_primitives::{Address, U256},",
      "    alloy_sol_types::{sol, SolError},",
      "    evm, msg,",
      "    prelude::*;",
      "};",
      "",
      "pub trait Erc20Params {",
      "    const NAME: &'static str;",
      "    const SYMBOL: &'static str;",
      "    const DECIMALS: u8;",
      "}",
      "",
      "sol_storage! {",
      "    /// Erc20 implements all ERC-20 methods.",
      "    pub struct Erc20<T> {",
      "        /// Maps users to balances",
      "        mapping(address => uint256) balances;",
      "        /// Maps users to a mapping of each spender's allowance",
      "        mapping(address => mapping(address => uint256)) allowances;",
      "        /// The total supply of the token",
      "        uint256 total_supply;",
      "        /// Used to allow [`Erc20Params`]",
      "        PhantomData<T> phantom;",
      "    }",
      "}",
      "",
      "// Declare events and Solidity error types",
      "sol! {",
      "    event Transfer(address indexed from, address indexed to, uint256 value);",
      "    event Approval(address indexed owner, address indexed spender, uint256 value);",
      "",
      "    error InsufficientBalance(address from, uint256 have, uint256 want);",
      "    error InsufficientAllowance(address owner, address spender, uint256 have, uint256 want);",
      "}",
      "",
      "pub enum Erc20Error {",
      "    InsufficientBalance(InsufficientBalance),",
      "    InsufficientAllowance(InsufficientAllowance),",
      "}",
      "",
      "// We will soon provide a #[derive(SolidityError)] to clean this up",
      "impl From<Erc20Error> for Vec<u8> {",
      "    fn from(err: Erc20Error) -> Vec<u8> {",
      "        match err {",
      "            Erc20Error::InsufficientBalance(e) => e.encode(),",
      "            Erc20Error::InsufficientAllowance(e) => e.encode(),",
      "        }",
      "    }",
      "}",
      "",
      "// These methods aren't exposed to other contracts",
      "// Note: modifying storage will become much prettier soon",
      "impl<T: Erc20Params> Erc20<T> {",
      "    pub fn transfer_impl(&mut self, from: Address, to: Address, value: U256) -> Result<(), Erc20Error> {",
      "        let mut sender_balance = self.balances.setter(from);",
      "        let old_sender_balance = sender_balance.get();",
      "        if old_sender_balance < value {",
      "            return Err(Erc20Error::InsufficientBalance(InsufficientBalance {",
      "                from,",
      "                have: old_sender_balance,",
      "                want: value,",
      "            }));",
      "        }",
      "        sender_balance.set(old_sender_balance - value);",
      "        let mut to_balance = self.balances.setter(to);",
      "        let new_to_balance = to_balance.get() + value;",
      "        to_balance.set(new_to_balance);",
      "        evm::log(Transfer { from, to, value });",
      "        Ok(())",
      "    }",
      "",
      "    pub fn mint(&mut self, address: Address, value: U256) {",
      "        let mut balance = self.balances.setter(address);",
      "        let new_balance = balance.get() + value;",
      "        balance.set(new_balance);",
      "        self.total_supply.set(self.total_supply.get() + value);",
      "        evm::log(Transfer {",
      "            from: Address::ZERO,",
      "            to: address,",
      "            value,",
      "        });",
      "    }",
      "",
      "    pub fn burn(&mut self, address: Address, value: U256) -> Result<(), Erc20Error> {",
      "        let mut balance = self.balances.setter(address);",
      "        let old_balance = balance.get();",
      "        if old_balance < value {",
      "            return Err(Erc20Error::InsufficientBalance(InsufficientBalance {",
      "                from: address,",
      "                have: old_balance,",
      "                want: value,",
      "            }));",
      "        }",
      "        balance.set(old_balance - value);",
      "        self.total_supply.set(self.total_supply.get() - value);",
      "        evm::log(Transfer {",
      "            from: address,",
      "            to: Address::ZERO,",
      "            value,",
      "        });",
      "        Ok(())",
      "    }",
      "}",
      "",
      "// These methods are external to other contracts",
      "// Note: modifying storage will become much prettier soon",
      "[external]",
      "impl<T: Erc20Params> Erc20<T> {",
      "    pub fn name() -> Result<String, Erc20Error> {",
      "        Ok(T::NAME.into())",
      "    }",
      "",
      "    pub fn symbol() -> Result<String, Erc20Error> {",
      "        Ok(T::SYMBOL.into())",
      "    }",
      "",
      "    pub fn decimals() -> Result<u8, Erc20Error> {",
      "        Ok(T::DECIMALS)",
      "    }",
      "",
      "    pub fn balance_of(&self, address: Address) -> Result<U256, Erc20Error> {",
      "        Ok(self.balances.get(address))",
      "    }",
      "",
      "    pub fn transfer(&mut self, to: Address, value: U256) -> Result<bool, Erc20Error> {",
      "        self.transfer_impl(msg::sender(), to, value)?;",
      "        Ok(true)",
      "    }",
      "",
      "    pub fn approve(&mut self, spender: Address, value: U256) -> Result<bool, Erc20Error> {",
      "        self.allowances.setter(msg::sender()).insert(spender, value);",
      "        evm::log(Approval {",
      "            owner: msg::sender(),",
      "            spender,",
      "            value,",
      "        });",
      "        Ok(true)",
      "    }",
      "",
      "    pub fn transfer_from(&mut self, from: Address, to: Address, value: U256) -> Result<bool, Erc20Error> {",
      "        let mut sender_allowances = self.allowances.setter(from);",
      "        let mut allowance = sender_allowances.setter(msg::sender());",
      "        let old_allowance = allowance.get();",
      "        if old_allowance < value {",
      "            return Err(Erc20Error::InsufficientAllowance(InsufficientAllowance {",
      "                owner: from,",
      "                spender: msg::sender(),",
      "                have: old_allowance,",
      "                want: value,",
      "            }));",
      "        }",
      "        allowance.set(old_allowance - value);",
      "        self.transfer_impl(from, to, value)?;",
      "        Ok(true)",
      "    }",
      "",
      "    pub fn allowance(&self, owner: Address, spender: Address) -> Result<U256, Erc20Error> {",
      "        Ok(self.allowances.getter(owner).get(spender))",
      "    }",
      "}"
    ],
    "description": "Erc20 smart contract"
  },
  "ERC721 Smart Contract Example": {
    "prefix": "erc721_smart_contract",
    "body": [
      "use alloc::{string::String, vec, vec::Vec};",
      "use alloy_primitives::{b256, Address, U256};",
      "use alloy_sol_types::{sol, SolError};",
      "use core::{borrow::BorrowMut, marker::PhantomData};",
      "use stylus_sdk::{abi::Bytes, evm, msg, prelude::*};",
      "",
      "pub trait ERC721Params {",
      "    /// Immutable NFT name.",
      "    const NAME: &'static str;",
      "",
      "    /// Immutable NFT symbol.",
      "    const SYMBOL: &'static str;",
      "",
      "    /// The NFT's Uniform Resource Identifier.",
      "    fn token_uri(token_id: U256) -> String;",
      "}",
      "",
      "sol_storage! {",
      "    /// ERC721 implements all ERC-721 methods",
      "    pub struct ERC721<T: ERC721Params> {",
      "        mapping(uint256 => address) owners;",
      "        mapping(uint256 => address) approved;",
      "        mapping(address => uint256) balance;",
      "        mapping(address => mapping(address => bool)) approved_for_all;",
      "        PhantomData<T> phantom;",
      "    }",
      "}",
      "",
      "// Declare events and Solidity error types",
      "sol! {",
      "    event Transfer(address indexed from, address indexed to, uint256 indexed token_id);",
      "    event Approval(address indexed owner, address indexed approved, uint256 indexed token_id);",
      "    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);",
      "",
      "    error AlreadyMinted();",
      "    error InvalidTokenId(uint256 token_id);",
      "    error NotOwner(address from, uint256 token_id, address real_owner);",
      "    error NotApproved(uint256 token_id, address owner, address spender);",
      "    error TransferToZero(uint256 token_id);",
      "    error ReceiverRefused(address receiver, uint256 token_id, bytes4 returned);",
      "}",
      "",
      "/// Represents the ways methods may fail.",
      "pub enum ERC721Error {",
      "    AlreadyMinted(AlreadyMinted),",
      "    InvalidTokenId(InvalidTokenId),",
      "    NotOwner(NotOwner),",
      "    NotApproved(NotApproved),",
      "    TransferToZero(TransferToZero),",
      "    ReceiverRefused(ReceiverRefused),",
      "    ExternalCall(stylus_sdk::call::Error),",
      "}",
      "",
      "/// We will soon provide a `#[derive(SolidityError)]` to clean this up.",
      "impl From<stylus_sdk::call::Error> for ERC721Error {",
      "    fn from(err: stylus_sdk::call::Error) -> Self {",
      "        Self::ExternalCall(err)",
      "    }",
      "}",
      "",
      "/// We will soon provide a `#[derive(SolidityError)]` to clean this up.",
      "impl From<ERC721Error> for Vec<u8> {",
      "    fn from(val: ERC721Error) -> Self {",
      "        match val {",
      "            ERC721Error::AlreadyMinted(err) => err.encode(),",
      "            ERC721Error::InvalidTokenId(err) => err.encode(),",
      "            ERC721Error::NotOwner(err) => err.encode(),",
      "            ERC721Error::NotApproved(err) => err.encode(),",
      "            ERC721Error::TransferToZero(err) => err.encode(),",
      "            ERC721Error::ReceiverRefused(err) => err.encode(),",
      "            ERC721Error::ExternalCall(err) => err.into(),",
      "        }",
      "    }",
      "}",
      "",
      "/// Simplifies the result type for the contract's methods.",
      "type Result<T, E = ERC721Error> = core::result::Result<T, E>;",
      "",
      "// These methods aren't external, but are helpers used by external methods.",
      "// Methods marked as \"pub\" here are usable outside of the erc721 module (i.e. they're callable from main.rs).",
      "impl<T: ERC721Params> ERC721<T> {",
      "    /// Requires that msg::sender() is authorized to spend a given token",
      "    fn require_authorized_to_spend(&self, from: Address, token_id: U256) -> Result<()> {",
      "        let owner = self.owner_of(token_id)?;",
      "        if from != owner {",
      "            return Err(ERC721Error::NotOwner(NotOwner {",
      "                from,",
      "                token_id,",
      "                real_owner: owner,",
      "            }));",
      "        }",
      "",
      "        if msg::sender() == owner {",
      "            return Ok(());",
      "        }",
      "        if self.approved_for_all.getter(owner).get(msg::sender()) {",
      "            return Ok(());",
      "        }",
      "        if msg::sender() == self.approved.get(token_id) {",
      "            return Ok(());",
      "        }",
      "        Err(ERC721Error::NotApproved(NotApproved {",
      "            owner,",
      "            spender: msg::sender(),",
      "            token_id,",
      "        }))",
      "    }",
      "",
      "    /// Transfers `token_id` from `from` to `to`.",
      "    /// This function does check that `from` is the owner of the token, but it does not check",
      "    /// that `to` is not the zero address, as this function is usable for burning.",
      "    pub fn transfer(&mut self, token_id: U256, from: Address, to: Address) -> Result<()> {",
      "        // function body",
      "    }",
      "",
      "    /// Additional ERC721 functions",
      "}",
      "",
      "sol_interface! {",
      "    /// Allows calls to the `onERC721Received` method of other contracts implementing `IERC721TokenReceiver`.",
      "    interface IERC721TokenReceiver {",
      "        function onERC721Received(address operator, address from, uint256 token_id, bytes data) external returns(bytes4);",
      "    }",
      "}",
      "",
      "/// Selector for `onERC721Received`, which is returned by contracts implementing `IERC721TokenReceiver`.",
      "const ERC721_TOKEN_RECEIVER_ID: u32 = 0x150b7a02;",
      "",
      "// these methods are external to other contracts",
      "[external]",
      "impl<T: ERC721Params> ERC721<T> {",
      "    /// Immutable NFT name.",
      "    pub fn name() -> Result<String> {",
      "        // function body",
      "    }",
      "",
      "    /// Additional external methods",
      "}"
    ],
    "description": "ERC721 smart contract implementation in Rust for blockchain development."
  },
  "Ed25519 Signature Verification Example": {
    "prefix": "ed25519_verify",
    "body": [
      "use alloy_primitives::FixedBytes;",
      "use stylus_sdk::abi::Bytes;",
      "use ed25519_compact::{PublicKey, Signature};",
      "",
      "/// Verifies an ed25519 signature.",
      "pub fn ed25519_verify(k: FixedBytes<32>, sig: Bytes, msg: Bytes) -> bool {",
      "    let pk: PublicKey = PublicKey::from_slice(k.as_slice()).unwrap();",
      "    let signature = Signature::from_slice(sig.as_slice()).unwrap();",
      "    pk.verify(msg, &signature).is_ok()",
      "}"
    ],
    "description": "Verifies an ed25519 signature."
  },
  "Rust Smart Contract Storage Definitions": {
    "prefix": "solidity_storage",
    "body": [
      "use stylus_sdk::prelude::solidity_storage",
      "use stylus_sdk::storage::StorageBool;",
      "use stylus_sdk::storage::StorageAddress;",
      "",
      "#[solidity_storage]",
      "pub struct Contract {",
      "    owner: StorageAddress,",
      "    active: StorageBool,",
      "    sub_struct: SubStruct,",
      "}",
      "",
      "#[solidity_storage]",
      "pub struct SubStruct {",
      "    // types implementing the `StorageType` trait.",
      "}"
    ],
    "description": "Define Rust smart contract storage"
  },
  "Solidity-Like Storage Definitions": {
    "prefix": "sol_storage",
    "body": [
      "use stylus_sdk::stylus_proc::sol_storage;",
      "",
      "sol_storage! {",
      "    pub struct Contract {",
      "        address owner;                      // becomes a StorageAddress",
      "        bool active;                        // becomes a StorageBool",
      "        SubStruct sub_struct,",
      "    }",
      "",
      "    pub struct SubStruct {",
      "        // other solidity fields, such as",
      "        mapping(address => uint) balances;  // becomes a StorageMap",
      "        Delegate delegates[];               // becomes a StorageVec",
      "    }",
      "}"
    ],
    "description": "Define Solidity-like storage in Rust"
  },
  "Reading and Writing Storage": {
    "prefix": "sol_storage_read_and_write",
    "body": [
      "impl Contract {",
      "    /// Gets the owner from storage.",
      "    pub fn owner(&self) -> Result<Address, Vec<u8>> {",
      "        Ok(self.owner.get())",
      "    }",
      "",
      "    /// Updates the owner in storage",
      "    pub fn set_owner(&mut self, new_owner: Address) -> Result<(), Vec<u8>> {",
      "        if msg::sender() == self.owner()? {",
      "            self.owner.set(new_owner);",
      "        }",
      "        Ok(())",
      "    }",
      "}"
    ],
    "description": "Access and modify contract storage"
  },
  "Collections": {
    "prefix": "sol_storage_collections",
    "body": [
      "impl SubStruct {",
      "    pub fn add_delegate(&mut self, delegate: Delegate) -> Result<(), Vec<u8>> {",
      "        self.delegates.push(delegate);",
      "    }",
      "",
      "    pub fn track_balance(&mut self, address: Address) -> Result<U256, Vec<u8>> {",
      "        self.balances.insert(address, address.balance());",
      "    }",
      "}"
    ],
    "description": "Operations on storage collections"
  },
  "Erase and #[derive(Erase)]": {
    "prefix": "erase",
    "body": [
      "sol_storage! {",
      "    #[derive(Erase)]",
      "    pub struct Contract {",
      "        address owner;              // can erase primitive",
      "        uint256[] hashes;           // can erase vector of primitive",
      "    }",
      "",
      "    pub struct NotErase {",
      "        mapping(address => uint) balances; // can't erase a map",
      "        mapping(uint => uint)[] roots;     // can't erase vector of maps",
      "    }",
      "}"
    ],
    "description": "Erase storage values"
  },
  "Storage Cache": {
    "prefix": "storage_cache",
    "body": [
      "// Use StorageCache for custom storage caching",
      "// Include unsafe methods for direct control",
      "// Refer to Stylus SDK documentation for details"
    ],
    "description": "Custom storage caching with StorageCache"
  },
  "Immutables and PhantomData": {
    "prefix": "immutables",
    "body": [
      "pub trait Erc20Params {",
      "    const NAME: &'static str;",
      "    const SYMBOL: &'static str;",
      "    const DECIMALS: u8;",
      "}",
      "",
      "sol_storage! {",
      "    pub struct Erc20<T> {",
      "        mapping(address => uint256) balances;",
      "        PhantomData<T> phantom;",
      "    }",
      "}"
    ],
    "description": "Using Immutables and PhantomData"
  }
}
